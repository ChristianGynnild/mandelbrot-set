// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

int screenWidth, screenHeight;
float zoom;
float angle;
uint maxIterations;
float centerReal, centerImaginary;


RWTexture2D<float4> Result;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint iterationCounter = 0;
    float ratio = (float)screenWidth/(float)screenHeight;
    float2 rotation = float2(cos(angle), sin(angle));


    float real, imaginary;
    float realSquared, imaginarySquared;


    float real0 = ((float)id.x/(float)screenWidth*ratio-0.5f*ratio)/zoom;
    float imaginary0 = ((float)id.y/(float)screenHeight-0.5f)/zoom;
    
    float realTemp = real0;
    float imaginaryTemp = imaginary0;

    real0 = realTemp*rotation.x-imaginaryTemp*rotation.y + centerReal;
    imaginary0 = realTemp*rotation.y+imaginaryTemp*rotation.x + centerImaginary;


    real = real0;
    imaginary = imaginary0;
    

    for (uint i = 0; i < maxIterations; i++){
        realSquared = real*real;
        imaginarySquared = imaginary*imaginary;

        if (realSquared+imaginarySquared > 4){
            break;
        }
        else{
            imaginary = 2.0 * real * imaginary + imaginary0;            
            real = realSquared-imaginarySquared + real0;
        }
        iterationCounter += 1;

    }

    float4 color = {0.0f, 0.0f, 0.0f, 1.0f};

    float4 hue = float4(0.17f, 1.784f, 0.335f, 1.0f);
    float val = sqrt((float)iterationCounter/(float)maxIterations)*20.0f;
    color = float4(
                sin(val*hue.r)*0.5f+0.5f,
                sin(val*hue.g)*0.5f+0.5f,
                sin(val*hue.b)*0.5f+0.5f,
                1.0);
    // if(iterationCounter != maxIterations){
    //     float val = iterationCounter/maxIterations;
    //     color = float4(val,val,val,val);
    // }


    Result[id.xy] = color;//float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
